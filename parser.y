%{
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>

int yylex();
void yyerror(const char *s);
extern int yylineno;
extern char* yytext;

int indent_level = 0;
int in_data_division = 0;
char* prog_name;
char* current_paragraph = NULL;
char* current_paragraph_params = NULL;
char* main_procedure_func = NULL;  // Variable para almacenar la función principal

typedef struct {
    char* name;
    int occurs;
} ArrayInfo;
ArrayInfo array_stack[100];
int array_stack_ptr = 0;

void emit(const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    for (int i = 0; i < indent_level; i++) {
        printf("    ");
    }
    vprintf(fmt, args);
    va_end(args);
    printf("\n");
}

char* format_identifier(char* id) {
    for (char* p = id; *p; ++p) {
        if (*p == '-') *p = '_';
        else *p = tolower(*p);
    }
    return id;
}

char* build_expr(const char* op, const char* left, const char* right) {
    char* expr;
    asprintf(&expr, "%s %s %s", left, op, right);
    return expr;
}

char* build_unary_expr(const char* op, const char* operand) {
    char* expr;
    asprintf(&expr, "%s%s", op, operand);
    return expr;
}

char* make_valid_function_name(const char* id) {
    if (id[0] >= '0' && id[0] <= '9') {
        char* new_name;
        asprintf(&new_name, "para_%s", id);
        return new_name;
    } else {
        return strdup(id);
    }
}

char* get_valid_function_name(const char* id) {
    char* formatted = format_identifier(strdup(id));
    char* valid_name = make_valid_function_name(formatted);
    free(formatted);
    return valid_name;
}

%}

%union {
    int    num;
    double dval;
    char*  str;
}

%right UMINUS
%left OR
%left AND
%right NOT
%nonassoc GREATER LESS GEQUAL LEQUAL EQUAL NEQUAL
%left PLUS MINUS
%left MUL_OP DIV_OP

%token IDENTIFICATION DIVISION PROGRAM_ID PROCEDURE
%token PROGRAM EXIT
%token AUTHOR INSTALLATION DATE_WRITTEN DATE_COMPILED SECURITY REMARKS
%token DATA FILE_TOKEN WORKING_STORAGE LOCAL_STORAGE LINKAGE SECTION
%token IF THEN ELSE END_IF END_PERFORM END_EVALUATE END
%token MOVE TO INTO_TOKEN DISPLAY ACCEPT COMPUTE ADD SUBTRACT MULTIPLY DIVIDE
%token PERFORM VARYING FROM BY UNTIL
%token GO PIC COMP COMP_3 VALUE VALUES
%token INDEXED OCCURS OCCURS_TIMES REDEFINES
%token CALL USING RETURNING
%token EVALUATE WHEN OTHER OR AND NOT
%token GREATER LESS GEQUAL LEQUAL EQUAL NEQUAL
%token PLUS MINUS MUL_OP DIV_OP
%token LPAREN RPAREN DOT COMMA_TOKEN
%token GOBACK ENVIRONMENT CONFIGURATION SOURCE_COMPUTER OBJECT_COMPUTER
%token INPUT_OUTPUT FILE_CONTROL
%token STOP RUN

%token <num> NUMBER BOOL
%token <dval> FLOAT
%token <str> IDENTIFIER STRING PIC_STRING

%type <str> expr condition
%type <str> pic_clause value_clause occurs_clause redefines_clause literal
%type <str> call_params literal_list evaluate_case
%type <str> logical_expr comparison param_list optional_using
%type <str> comp_clause

%%

program:
    identification_division
    optional_environment_division
    data_division
    procedure_division
    end_program
    {
        emit("\nif __name__ == '__main__':");
        emit("    %s()", prog_name);
    }
;

optional_environment_division:
    /* empty */
    | environment_division
;

environment_division:
    ENVIRONMENT DIVISION optional_dot
    environment_sections
;

end_program: 
    END PROGRAM IDENTIFIER DOT 
    {
        if (main_procedure_func) {
            free(main_procedure_func);
            main_procedure_func = NULL;
        }
        emit("# END PROGRAM %s", $3);
    }
    | END PROGRAM DOT
    {
        if (main_procedure_func) {
            free(main_procedure_func);
            main_procedure_func = NULL;
        }
        emit("# END PROGRAM");
    }
;

identification_division:
    IDENTIFICATION DIVISION optional_dot
    identification_entries
    {
        emit("#!/usr/bin/env python3");
        emit("# Generated by COBOL-85 to Python compiler");
        emit("import sys");
        emit("def %s():", prog_name);
        indent_level++;
    }
;

optional_dot:
    /* empty */
    | DOT
;

identification_entries:
    identification_entry
    | identification_entries identification_entry
;

identification_entry:
    PROGRAM_ID optional_dot IDENTIFIER optional_dot { 
        prog_name = strdup($3); 
        emit("# PROGRAM-ID: %s", $3);
    }
    | AUTHOR optional_dot IDENTIFIER optional_dot { 
        emit("# AUTHOR: %s", $3); 
    }
    | AUTHOR optional_dot STRING optional_dot { 
        emit("# AUTHOR: %s", $3); 
    }
    | INSTALLATION optional_dot IDENTIFIER optional_dot { 
        emit("# INSTALLATION: %s", $3); 
    }
    | INSTALLATION optional_dot STRING optional_dot { 
        emit("# INSTALLATION: %s", $3); 
    }
    | DATE_WRITTEN optional_dot IDENTIFIER optional_dot { 
        emit("# DATE-WRITTEN: %s", $3); 
    }
    | DATE_WRITTEN optional_dot STRING optional_dot { 
        emit("# DATE-WRITTEN: %s", $3); 
    }
    | DATE_COMPILED optional_dot IDENTIFIER optional_dot { 
        emit("# DATE-COMPILED: %s", $3); 
    }
    | DATE_COMPILED optional_dot STRING optional_dot { 
        emit("# DATE-COMPILED: %s", $3); 
    }
    | SECURITY optional_dot IDENTIFIER optional_dot { 
        emit("# SECURITY: %s", $3); 
    }
    | SECURITY optional_dot STRING optional_dot { 
        emit("# SECURITY: %s", $3); 
    }
    | REMARKS optional_dot IDENTIFIER optional_dot { 
        emit("# REMARKS: %s", $3); 
    }
    | REMARKS optional_dot STRING optional_dot { 
        emit("# REMARKS: %s", $3); 
    }
;

environment_sections:
    /* empty */
    | environment_sections environment_section
;

environment_section:
    configuration_section
    | input_output_section
;

configuration_section:
    CONFIGURATION SECTION optional_dot
    configuration_paragraphs
;

configuration_paragraphs:
    /* empty */
    | configuration_paragraphs configuration_paragraph
;

configuration_paragraph:
    SOURCE_COMPUTER optional_dot IDENTIFIER optional_dot { 
        emit("# SOURCE-COMPUTER: %s", $3); 
    }
    | OBJECT_COMPUTER optional_dot IDENTIFIER optional_dot { 
        emit("# OBJECT-COMPUTER: %s", $3); 
    }
;

input_output_section:
    INPUT_OUTPUT SECTION optional_dot
    input_output_paragraphs
;

input_output_paragraphs:
    /* empty */
    | input_output_paragraphs input_output_paragraph
;

input_output_paragraph:
    FILE_CONTROL optional_dot { emit("# FILE-CONTROL"); }
;

data_division:
    DATA DIVISION optional_dot
    { in_data_division = 1; }
    data_sections
    { in_data_division = 0; }
;

data_sections:
    /* empty */
    | data_sections data_section
;

data_section:
    FILE_TOKEN SECTION optional_dot
    | WORKING_STORAGE SECTION optional_dot data_items
    | LOCAL_STORAGE SECTION optional_dot data_items
    | LINKAGE SECTION optional_dot param_items
;

data_items:
    /* empty */
    | data_items data_item
;

param_items:
    /* empty */
    | param_items param_item
;

data_item:
    level_number IDENTIFIER 
    pic_clause 
    comp_clause
    value_clause 
    occurs_clause 
    redefines_clause 
    optional_dot
    {
        if ($5) emit("%s = %s", $2, $5);
        else if ($6) emit("%s = [None] * %s", $2, $6);
        else emit("%s = None", $2);
    }
;

param_item:
    level_number IDENTIFIER 
    pic_clause 
    comp_clause
    optional_dot
    {
        emit("# Parameter: %s", $2);
    }
;

level_number:
    NUMBER
;

pic_clause:
    /* empty */ { $$ = NULL; }
    | PIC PIC_STRING { $$ = $2; }
;

comp_clause:
    /* empty */ { $$ = NULL; }
    | COMP { $$ = NULL; }
    | COMP_3 { $$ = NULL; }
;

value_clause:
    /* empty */ { $$ = NULL; }
    | VALUE literal { $$ = $2; }
;

occurs_clause:
    /* empty */ { $$ = NULL; }
    | OCCURS NUMBER OCCURS_TIMES { 
        char* occurs = malloc(20);
        sprintf(occurs, "%d", $2);
        $$ = occurs;
    }
;

redefines_clause:
    /* empty */ { $$ = NULL; }
    | REDEFINES IDENTIFIER { $$ = $2; }
;

literal:
    NUMBER { 
        char* buf;
        asprintf(&buf, "%d", $1);
        $$ = buf;
    }
  | FLOAT { 
        char* buf;
        asprintf(&buf, "%f", $1);
        $$ = buf;
    }
  | STRING { $$ = $1; }
  | BOOL { 
        $$ = $1 ? strdup("True") : strdup("False"); 
    }
;

procedure_division:
    PROCEDURE DIVISION optional_using optional_dot
    {
        if ($3) {
            current_paragraph_params = strdup($3);
        }
    }
    paragraphs
    {
        // Llamar a la función principal después de definir todas las funciones
        if (main_procedure_func) {
            emit("%s()  # Llamada a la función principal", main_procedure_func);
        }
        indent_level--;
        emit("");
    }
;

optional_using:
    /* empty */ { $$ = NULL; }
    | USING param_list { $$ = $2; }
;

param_list:
    IDENTIFIER { 
        $$ = format_identifier($1);
    }
    | param_list COMMA_TOKEN IDENTIFIER { 
        char* new_param;
        asprintf(&new_param, "%s, %s", $1, format_identifier($3));
        $$ = new_param;
    }
;

paragraphs:
    paragraph
    | paragraphs paragraph
;

paragraph:
    paragraph_header optional_dot
    statements
    {
        indent_level--;
        emit("");
        if (current_paragraph_params) {
            free(current_paragraph_params);
            current_paragraph_params = NULL;
        }
    }
;

paragraph_header:
    IDENTIFIER 
    {
        current_paragraph = strdup($1);
        char* func_name = make_valid_function_name($1);
        emit("");
        
        // Guardar la primera función como principal
        if (main_procedure_func == NULL) {
            main_procedure_func = strdup(func_name);
        }
        
        if (strcmp($1, prog_name) == 0) {
            if (current_paragraph_params) {
                emit("def %s(%s):", func_name, current_paragraph_params);
            } else {
                emit("def %s():", func_name);
            }
        } else {
            emit("def %s():", func_name);
            // Agregar declaración nonlocal para todas las variables
            emit("    nonlocal n_input, n, total, x, y, z, exp_x, exp_y, exp_z, suma, ws_base, ws_exp, ws_result, ws_j");
        }
        free(func_name);
        indent_level++;
    }
;

statements:
    /* empty */
    | statements statement
;

statement:
    MOVE expr TO IDENTIFIER optional_dot
    { emit("%s = %s", $4, $2); }
  | IF condition optional_then
    {
        emit("if %s:", $2);
        indent_level++;
    } 
    statements 
    opt_else
    END_IF optional_dot
    { indent_level--; }
  | EVALUATE expr
    {
        emit("match %s:", $2);
        indent_level++;
    }
    evaluate_cases
    opt_other
    END_EVALUATE optional_dot
    { indent_level--; }
  | DISPLAY expr optional_dot
    { emit("print(%s)", $2); }
  | ACCEPT IDENTIFIER optional_dot
    { emit("%s = int(input())", $2); }  // Convertir a entero
  | COMPUTE IDENTIFIER EQUAL expr optional_dot
    { emit("%s = %s", $2, $4); }
  | ADD expr TO IDENTIFIER optional_dot
    { emit("%s += %s", $4, $2); }
  | SUBTRACT expr FROM IDENTIFIER optional_dot
    { emit("%s -= %s", $4, $2); }
  | MULTIPLY IDENTIFIER BY expr optional_dot
    { emit("%s *= %s", $2, $4); }
  | DIVIDE IDENTIFIER INTO_TOKEN expr optional_dot
    { emit("%s = %s / %s", $4, $4, $2); }
  | PERFORM VARYING IDENTIFIER FROM expr BY expr UNTIL condition optional_dot
    {
        emit("%s = %s", $3, $5);
        emit("while not (%s):", $9);  // Condición corregida
        indent_level++;
    } 
    statements 
    END_PERFORM optional_dot
    {
        emit("%s += %s", $3, $7);
        indent_level--;
    }
  | PERFORM UNTIL condition optional_dot
    {
        emit("while not (%s):", $3);  // Condición corregida
        indent_level++;
    }
    statements
    END_PERFORM optional_dot
    {
        indent_level--;
    }
  | PERFORM IDENTIFIER optional_dot
    { 
        char* func_name = get_valid_function_name($2);
        emit("%s()", func_name);
        free(func_name);
    }
  | CALL IDENTIFIER USING call_params optional_dot
    { 
        char* func_name = get_valid_function_name($2);
        emit("%s(%s)", func_name, $4);
        free(func_name);
    }
  | GO TO IDENTIFIER optional_dot
    {
        char* func_name = get_valid_function_name($3);
        emit("%s()", func_name);
        emit("return");
        free(func_name);
    }
  | GOBACK optional_dot
    {
        emit("return");
    }
  | EXIT PROGRAM optional_dot
    {
        emit("sys.exit(0)");
    }
  | STOP RUN optional_dot
    {
        emit("sys.exit(0)");
    }
;

optional_then:
    /* empty */
    | THEN
;

opt_else:
    /* empty */
    | ELSE
      {
          indent_level--;
          emit("else:");
          indent_level++;
      }
      statements
;

evaluate_cases:
    evaluate_case
    | evaluate_cases evaluate_case
;

evaluate_case:
    WHEN literal_list
    {
        emit("case %s:", $2);
        indent_level++;
    }
    statements
    { indent_level--; }
;

opt_other:
    /* empty */
    | WHEN OTHER
    {
        emit("case _:");
        indent_level++;
    }
    statements
    { indent_level--; }
;

literal_list:
    expr
    | literal_list OR expr
;

call_params:
    expr
    | call_params COMMA_TOKEN expr
;

condition: logical_expr ;

logical_expr:
    logical_expr OR logical_expr   { $$ = build_expr("or", $1, $3); }
  | logical_expr AND logical_expr  { $$ = build_expr("and", $1, $3); }
  | NOT logical_expr               { $$ = build_unary_expr("not ", $2); }
  | comparison                     { $$ = $1; }
  | LPAREN logical_expr RPAREN     { $$ = $2; }
;

comparison:
    expr GREATER expr  { $$ = build_expr(">", $1, $3); }
  | expr LESS expr     { $$ = build_expr("<", $1, $3); }
  | expr GEQUAL expr   { $$ = build_expr(">=", $1, $3); }
  | expr LEQUAL expr   { $$ = build_expr("<=", $1, $3); }
  | expr EQUAL expr    { $$ = build_expr("==", $1, $3); }
  | expr NEQUAL expr   { $$ = build_expr("!=", $1, $3); }
;

expr:
    NUMBER { 
        char* buf;
        asprintf(&buf, "%d", $1);
        $$ = buf;
    }
  | FLOAT { 
        char* buf;
        asprintf(&buf, "%f", $1);
        $$ = buf;
    }
  | IDENTIFIER { $$ = format_identifier($1); }
  | STRING     { $$ = $1; }
  | expr PLUS expr  { $$ = build_expr("+", $1, $3); }
  | expr MINUS expr { $$ = build_expr("-", $1, $3); }
  | expr MUL_OP expr { $$ = build_expr("*", $1, $3); }
  | expr DIV_OP expr { $$ = build_expr("/", $1, $3); }
  | MINUS expr %prec UMINUS     { $$ = build_unary_expr("-", $2); }
  | LPAREN expr RPAREN { $$ = $2; }
;

%%

void yyerror(const char *s) {
    fprintf(stderr, "Error at line %d: %s. Token: '%s' (Length: %d)\n", 
            yylineno, s, yytext, (int)strlen(yytext));
    for (int i = 0; yytext[i]; i++) {
        fprintf(stderr, "Char %d: %d\n", i, (unsigned char)yytext[i]);
    }
    exit(1);
}

int main() {
    yyparse();
    return 0;
}